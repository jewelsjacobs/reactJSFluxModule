#!/bin/bash
#
# /etc/init.d/gui
# Subsystem file for GUI server.
#
# chkconfig: - 99 01
# description: Manage the GUI Gunicorn server.

####################
# GLOBAL VARIABLES #
####################
APP='gui'

ACCESS_LOGFILE="/var/log/gunicorn/access_$APP.log"
GUI_GROUP='orocket'
GUI_USER='orocket'
APP_DIRECTORY='/gui'
DISPLAY_NAME='GUI'
ERROR_LOGFILE="/var/log/gunicorn/error_$APP.log"
GUNICORN_PATH='/root/.virtualenvs/current/bin/gunicorn'
PACKAGE_NAME='gui'
PIDFILE="/var/run/$APP.pid"
PORT='8081'

# Not currently being used because gui code attempts a top-level import which requires access to
# the app instance. Will use this code when refactor of gui modules is complete.
if [ -e '/etc/viper_development.txt' ]; then
    CONFIG='development'
elif [ -e '/etc/viper_qa.txt' ]; then
    CONFIG='qa'
else
    CONFIG='production'
fi

RV=0


##################
# START FUNCTION #
##################
start() {

    # Ensure the $APP_DIRECTORY is in place, else application code will not be in place.
    check_app_directory_or_exit

    # Ensure $GUI_USER and $GUI_GROUP exist, else gunicorn will not start properly.
    check_orocket_user_and_group_or_exit

    # Ensure the $GUNICORN_PATH exist, else gunicorn will not start properly.
    check_gunicorn_or_exit

    # Ensure the application code exist, else gunicorn will not start properly.
    check_application_package_or_exit

    # Move to application's source directory.
    cd "$APP_DIRECTORY"

    if [ -f "$PIDFILE" ]; then
        # Check if process is already running.
        PID=$(cat "$PIDFILE")
        if ps -fp "$PID" > /dev/null 2>&1; then
            echo "$DISPLAY_NAME is already running."
            return

        else
            rm -f "$PIDFILE"
        fi
    fi

    echo -n "Daemonizing $DISPLAY_NAME gunicorn on port $PORT, let's do this ... "

    "$GUNICORN_PATH" \
        -D \
        -w 16 \
        -t 120 \
        -k gevent \
        -u $GUI_USER \
        -g $GUI_GROUP \
        -p "$PIDFILE" \
        -b "0.0.0.0:$PORT" \
        --error-logfile="$ERROR_LOGFILE" \
        --access-logfile="$ACCESS_LOGFILE" \
        "$PACKAGE_NAME:app"

    # Count the number of processes running.
    sleep 3
    count_procs
    return
}


#################
# STOP FUNCTION #
#################
stop() {

    # Test if pidfile exists.
    if [ ! -f "$PIDFILE" ]; then
        echo "No pidfile found for $DISPLAY_NAME."
        return

    else
        # Get and test PID.
        PID=$(cat "$PIDFILE")
        ps -fp "$PID" > /dev/null 2>&1

        # Clean up pidfile if process was manually killed.
        if [ $? -ne 0 ]; then
            echo "Valid pidfile found, but the pid isn't running. Removing pidfile."
            rm -f $PIDFILE
            return

        # Kill process.
        else
            count_procs
            echo "Killing processes."
            kill $PID 2>/dev/null
            sleep 1
            kill -9 $PID 2>/dev/null
            return
        fi
    fi
}


####################
# RESTART FUNCTION #
####################
restart() {
    stop

    # Start if stop succeeded.
    if [ "$RV" -eq 0 ]; then
        start
    fi
}


###################
# STATUS FUNCTION #
###################
status() {

    # Check if pidfile exists.
    if [ ! -f "$PIDFILE" ]; then
        echo "$DISPLAY_NAME is not running (pidfile not found)."
        return
    fi

    # Count the number of processes running for $DISPLAY_NAME.
    count_procs
    return
}


##################
# USAGE FUNCTION #
##################
usage() {
cat <<EOF
gui [ start | stop | restart | status ]

    start     Start the GUI Gunicorn server.

    stop      Stop the GUI Gunicorn server.

    restart   Restart the GUI Gunicorn server.

    status    Get the status of the GUI Gunicorn server.

EOF
RV=1
}


####################
# HELPER FUNCTIONS #
####################
# Ensure the $APP_DIRECTORY is in place, else application code will not be in place.
check_app_directory_or_exit() {
    if [ ! -d "$APP_DIRECTORY" ]; then
        echo "The directory '$APP_DIRECTORY' was not found. This means the $DISPLAY_NAME application code is not in place. Exiting."
        exit 1
    fi
}


# Ensure the $GUNICORN_PATH exist, else gunicorn will not start properly.
check_gunicorn_or_exit() {
    if [ ! -e "$GUNICORN_PATH" ]; then
        echo "The target '$GUNICORN_PATH' was not found. Gunicorn will not start properly. Exiting."
        exit 1
    fi
}


# Ensure the application code exist, else gunicorn will not start properly.
check_application_package_or_exit() {
    package_location="$APP_DIRECTORY/$PACKAGE_NAME"
    if [ ! -d $package_location ]; then
        echo "The application package '$package_location' was not found. Application will not start properly. Exiting."
        exit 1
    fi
}


# Ensure $GUI_USER and $GUI_GROUP exist, else gunicorn will not start properly.
check_orocket_user_and_group_or_exit() {
    # Check for the existence of $GUI_USER.
    id -u $GUI_USER &> /dev/null
    if [ ! "$?" -eq "0" ]; then
        echo "User '$GUI_USER' does not appear to exist. This user is needed to run $DISPLAY_NAME. Exiting."
        exit 1
    fi

    # Check for the existence of $GUI_GROUP.
    id -g $GUI_GROUP &> /dev/null
    if [ ! "$?" -eq "0" ]; then
        echo "Group '$GUI_GROUP' does not appear to exist. This group is needed to run $DISPLAY_NAME. Exiting."
        exit 1
    fi
}

# Count, and report on, the number of Gunicorn processes currently running.
count_procs() {
    count=$(ps -ef | egrep -c "[g]unicorn.*$APP")
    echo "$count processes running."
}


########################
# PROCESS COMMAND LINE #
########################
case "$1" in
    'start')
        start
    ;;
    'stop')
        stop
    ;;
    'restart')
        restart
    ;;
    'status')
        status
    ;;
    *)
        usage
    ;;
esac

exit "$RV"
